# # new 연산자로 배열 생성

``` shell
타입 [] 변수 = new 타입 [길이];
타입 변수 [] = new 타입 [길이];
```

``` java
int lotto[]= new int [6];
//번호 생성
for(int i=0;i<6;i++) {
    lotto[i]=(int)(Math.random()*45)+1;
    //중복번호 제거
    for(int j=0;j<i;j++) {
        if(lotto[j])==lotto[i]) {
            i--;
            break;
        }
    }   
}
for(int i=0;i<6;i++) {
 System.out.println(lotto[i]+" ")
     } 
   } 
}
```

`Exception in thread "main` 

- 이것은 배열의 범위를 넘어선 값을 넣었을 경우 발생하는 에러이다.



# 6장 클래스

##  1.객체와 클래스

> 클래스로부터 객체를 얻는 과정 = `인스턴스`
>
> 클래스로부터 여러 개의 인스턴스를 만들 수 있다.
>
> 클래스에는 객체를 생성하기 위한 `필드`와 `메소드`가 정의되어 있다.

###    

###    1) 클래스의 용도

####        1. 라이브러리(API) 용: 다른 클래스에서 이용할 목적

####        2. 실행용: 프로그램의 실행 진입점인 main() 메소드를 제공하는 역할

- > 대부분의 객체 지향 프로그램은 라이브러리(부품 객체 및 완성 객체)와 실행클래스가 분리되어 있다.



###     2) 클래스의 구성멤버

####        1. 필드

- 객체의 고유 데이터, 부품객체, 상태 정보를 저장하는 곳. 

  ``` java
  타입 필드(명) [= 초기값];
  int speed;
  int maxSpeed= 300;
  ```

  

- ``` java
  Car myCar= new Car();
  myCar.speed= 60;
  ```

- myCar 변수가 Car 객체를 참조하게 되면 `도트(.) 연산자`를 사용해서 speed  필드에 접근할 수 있다.

- 클래스 작성 시 데이터 값을 기입하지 않고, 객체 생성 시점(후)에 기입할 때, 

- 객체 클래스에서 필드 선언 후, 생성자의 매개값으로 이 값들을 받아 초기화한다. 

- ``` java
  //생성자
  public car (String m, Stirng c) {
      this.model= model;
      this.color= color;
  }
  ```

  

####        2. 생성자

- new 연산자로 호출되는 특별한 중괄호 {} 블록.

- 객체 생성 시, 초기화 담당. (생성자를 실행시키지 않고 객체를 만드는 것은 불가능)

- 리턴 타입 없음.

- 생성자가 명시적으로 선언되어 있을 경우, 반드시 선언된 생성자를 호출해서 객체를 생성해야 한다.

- <b>`생성자 오버로딩`:  매개 변수를 달리하는 생성자를 여러 개 선언하는 것</b>

- <b>다른 생성자 호출(this())</b>: 필드 초기화 내용은 한 생성자에만 집중적으로 작성하고, 나머지 생성자는 초기화 내용을 가지고 있는 생성자를 호출하는 방법으로 개선

  ``` java
  클래스([매개변수 선언,...]) {
      this(매개변수,...,값,...);   //클래스의 다른 생성자 호출
      실행문;  // 호출되는 생성자의 실행이 끝나면 원래 생성자로 돌아와서 다음 실행문을 진행
  }
  ```

  > this()는 자신의 다른 생성자를 호출하는 코드로 반드시 생성자의 첫 줄에서만 허용



####        3. 메소드

- 객체의 동작에 해당하는 중괄호 {}블록.

- 객체 간 데이터 전달의 수단으로 사용.

- 외부로부터 매개값을 받을 수도 있고, 실행 후 어떤 값을 리턴할 수도 있음.

- 메소드는 필드를 읽고 수정하는 역할도 하지만, 다른 객체를 생성해서 다양한 기능을 수행하기도 한다.

- 메소드는 리턴값이 있을 수도 없을 수도 있다.(리턴값이 없으면 리턴타입에 `void`가 와야함.)

  ``` java
  리턴타입 메소드이름([매개변수 선언,...]) {
      // 메소드 실행 블록
  }
  -------
  void powerOn() {...}  //리턴 값 x
  double divide(int x,int y) {...} // divide 후 double 타입으로 저장할 변수 필요(ex:result)
  ```

  - 리턴 타입이 있다고 해서 반드시 리턴값을 변수에 저장할 필요는 없다.

-  매개 변수선언: 메소드가 실행할 때 필요한 데이터를 외부로부터 받기 위해 사용

  <매개 변수 수를 모를 경우>

  ``` java
  int sum1(int[] values) {}   // 메소드 호출 전 배열을 생성해야 함.
  int sum2(int... values) {}   // 메소드 호출 시 넘겨준 값의 수에 따라 자동으로 배열 생성되고 매개값으로 사용됨.
  ```

- 리턴값이 있는 메소드는 반드시 `return 리턴값;` 을 입력해야 한다.

- 리턴값이 없는 메소드에서도 `return` 문을 사용할 수 있다. `return;`으로 메소드 실행 종료

- 메소드는 클래스 내 외부의 호출에 의해 실행된다.  

- <객체 외부에서 호출> 우선 클래스로부터 객체를 생성한 뒤, 참조 변수를 이용해서 메소드를 호출해야 한다. 

- <객체내부에서 호출>

  ```shell
  메소드(매개값,...);   //메소드가 매개변수를 갖고있을 경우 매개 변수의 타입과 수에 맞게 매개 값을 제공
  ```

- `메소드 오버로딩:` 매개값을 다양하게 받아 처리할 수 있도록 하기 위해서, 클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것.



### 3) 인스턴스 멤버와 this

> 인스턴스 멤버란 객체를 생성한 후 사용할 수 있는 필드와 메소드를 말하는 데, 이들을 각각 인스턴스 필드, 인스턴스 메소드라고 부른다.

- 참조 변수 `this` = 주로 생성자와 메소드의 매개변수 이름이 필드와 동일한 경우, 인스턴스 멤버인 필드임을 명시하고자 할 때 사용

- 인스턴스 필드는 객체마다 따로 존재하고, 인스턴스 메소드는 객체마다 존재하지 않고, 메소드 영역에 저장되고 공유된다.

  ``` java
  int gas; //인스턴스 필드
  void setSpeed(int speed) {...} //인스턴스 메소드
  ```



### 4) 정적멤버와 static

> 정적멤버는 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드를 말한다.
>
> 객체(인스턴스)에 소속된 멤버가 아니라, 클래스에 소속된 멤버이기 때문에 클래스 멤버라고도 한다.

``` java
static 타입 필드 //정적 필드
static 리턴 타입 메소드(매개변수 선언,...) {...}  //정적 메소드    
```

- 정적 블록의 형태= static { ... }

- 정적 메소드와 정적 블록에서 인스턴스 멤버를 사용하고 싶다면, 객체를 먼저 생성하고 참조변수로 접근해야 한다.
- main() 메소드도 동일한 규칙 적용. 객체 생성없이 인스턴스 필드, 메소드 바로 사용 불가.



### 5) 싱글톤(getInstance)

> 단 하나의 객체만을 생성하도록 막는 것. 앞에 접근 제한자 private를 붙여준다

- 싱글톤을 외부에서 객체를 얻는 방법

  ``` java
  Singleton obj1 = new Singleton(); //(x) 틀림
  Singleton obj1 - Singleton.getInstance(); //(O) getInstance() 메소드는 단 하나의 객체만 리턴, 여러 싱글톤 객체를 만들어도 같은 객체임.
  ```



### 6) final 필드

``` java
final 타입 필드 [=초기값];  //final 필드는 변경 불가
```



### 7) 상수(static final)

> 불변의 값= 상수 , `상수는 모두 대문자로 쓸 것`
>
> static final 필드는 객체마다 저장되지 않고, 클래스에만 포함

``` java
static fianl 타입 상수 [=초기값];  // 초기값이 단순할 경우

static final 타입 상수;    //초기값 복잡할 경우
static {
    상수= 초기값;
}
```



### 8) 패키지

> 폴더를 만들어 파일을 저장하고 관리하듯이 패키지를 만들어 클래스를 저장 관리한다.
>
> 패키지의 물리적 형태는 파일 시스템의 폴더이다.   `패키지는 모두 소문자로 쓸 것!`
>
> 패키지는 클래스를 유일하게 만들어주는 식별자 역할도 한다.

<상위패키지.하위패키지.클래스>

####   1. import 문

- 다른 패키지에 속하는 클래스를 사용하려면, 사용하고자 하는 패키지를 import 문으로 선언하고, 클래스를 사용할 때에는 패키지를 생략하는 것이다.

- 패키지에 포함된 다수의 클래스를 사용해야 한다면, *을 사용한다

  ``` java
  package com.mycompany;
   
   import com.hankook.*;
  ```

  - `import`문으로 지정된 패키지의 하위 패키지는 `import` 대상이 아니다. 사용하려면 추가로 `import` 문을 작성해야 한다.

#####   <b>ctrl + shift + O </b> => import 문을 작성하지 않아도, 사용된 클래스를 조사해서 필요한 import 문을 자동적으로 추가하는 기능



### 9) Getter 와 Setter 메소드

> 데이터는 외부에서 접근할 수 없도록 막고 메소드는 공개해서, 외부에서 메소드를 통해 데이터에 접근하도록 유도한다.
>
> 그 이유는 메소드는 매개값을 검증해서 유효한 값만 데이터로 저장할 수  있기 때문이다.
>
> 이러한 역할을 하는 메소드가 `Settter`이다.
>
> ``` java
> void setSpeed(double speed) {      //매개값이 음수일 경우 speed 필드에 0으로 저장하고 메소드 실행 종료
>     if(speed<0) {
>         this.speed=0;
>         return;
>     } else {
>         this.speed = speed;
>     }
> }
> ```



- 객체 외부에서 객체의 필드값으로 사용하기 부적절한 경우도 있다. 이 경우 메소드로 필드값을 가공 후, 외부로 전달하는데 이러한 역할을 하는 메소드가 `Getter`이다.

  ``` java
  double getSpeed() {                          // 필드값인 마일을 km 단위로 환산 후 외부로 리턴
      double km = speed *1.6;
      return km;
  }
  ```

- 클래스 선언 시 가능하다면 필드를 `private`로 선언해서 외부로부터 보호하고, 필드에 대한 Setter와 Getter 메소드를 작성해서 필드값을 안전하게 변경/사용하는 것이 좋다.

  ``` java
  private 타입 fieldName;
  
  //Getter
  public 리턴타입 getFieldName() {
      return fieldName;
  }
  //Setter
  public void setFieldName(타입 fieldName) {
      this.fieldName= fieldName;
  }
  ```

- 필드 타입이 boolean일 경우 Gettter는 get으로 시작하지 않고 is로 시작하는 것이 관례이다.

  ``` java
  private boolean stop;
  
  //Getter
  public boolean isStop() {
      return stop;
  }
  
  //Setter
  public void setStop(boolean stop) {
      this.stop= stop;
  }
  ```

  

`!가 붙는 것은 not 부정의 의미이다`



###  10) 어노테이션

> 어노테이션은 메타데이터라고 볼 수 있다. 메타 데이터란 애플리케이션이 처리해야 할 데이터가 아니라, 컴파일 과정과 실행과정에서 코드를 어떻게 컴파일하고 처리할 것인지를 알려주는 정보이다.

<용도>

- 컴파일러에게 코드 문법에러를 체크하도록 정보제공
- 소프트웨어 개발 툴이 빌드나 배치 시 코드를 자동으로 생성할 수 있도록 정보를 제공
- 실행 시  특정기능을 실행하도록 정보 제공

